## Technical Requirements Document (TRD) for the VLM Project

### Project Overview
The Visual Learning Model (VLM) project aims to create a platform that analyzes video content, generates overview summaries, and detects objects from the videos. The frontend is developed using React, while the backend uses Flask to handle API requests and data processing.

### Component Breakdown

1. **App.js**
   - **Location:** `/AQuA/React_ver/react_Frontend/src/App.js`
   - **Purpose:** 
     - Serves as the main application container that integrates various components like `VideoDisplay`, `Prompting`, and `Scheduler`.
     - Manages state for groups and items, which represent the timeline data for video analysis.
   - **Key Functionalities:**
     - Fetches timeline data from the backend via `fetchTimelineData` function.
     - Uses the `moment` library to handle time-related transformations.
     - Renders child components and passes down required props.
     - Logs and handles errors during data fetch operations.

2. **Prompting.js**
   - **Location:** `/AQuA/React_ver/react_Frontend/src/Prompting.js`
   - **Purpose:** 
     - Provides a chat interface where users can interact with the backend LLM (Large Language Model) API.
     - Displays suggestions generated by the LLM for follow-up questions.
   - **Key Functionalities:**
     - Initializes the conversation with a welcome message using `useEffect`.
     - Handles user input, sends it to the backend, and updates the chat history.
     - Displays suggestions and allows users to click on them to autofill the input box.
     - Manages error handling for API requests and scrolls the chat box automatically as new messages arrive.

3. **VideoDisplay.js**
   - **Location:** `/AQuA/React_ver/react_Frontend/src/VideoDisplay.js`
   - **Purpose:**
     - Displays video and audio files fetched from the backend after running a script.
   - **Key Functionalities:**
     - Provides a button to trigger the backend script execution.
     - Fetches the most recent video and audio files from the backend.
     - Converts the fetched media into a format suitable for playback in the browser.
     - Handles and logs errors that occur during API requests.

4. **Backend (app.py)**
   - **Location:** `/AQuA/React_ver/flask_Backend/app.py`
   - **Purpose:**
     - Handles backend operations such as running scripts, fetching data, and responding to API requests.
   - **Key Functionalities:**
     - API endpoints for executing scripts (`/run-script`), fetching recent video (`/video/recent`), and audio files (`/audio/recent`).
     - Manages data processing and error handling on the server side.
     - Interacts with the Flask framework for routing and handling HTTP requests.


---

# Detailed README for the VLM Project:

### VLM Project

Welcome to the Visual Learning Model (VLM) project! This project aims to analyze videos, generate summary scripts, and detect objects, all integrated into a modern web application.

#### Table of Contents

1. [Project Structure](#project-structure)
2. [Installation](#installation)
3. [Usage](#usage)
4. [Components](#components)
   - [App.js](#appjs)
   - [Prompting.js](#promptingjs)
   - [VideoDisplay.js](#videodisplayjs)
5. [Backend API](#backend-api)

#### Project Structure

```
AQuA/
│
├── React_ver/
│   ├── react_Frontend/
│   │   ├── src/
│   │   │   ├── App.js
│   │   │   ├── Prompting.js
│   │   │   ├── VideoDisplay.js
│   │   │   └── ...
│   └── flask_Backend/
│       ├── app.py
│       └── ...
└── ...
```

#### Installation

1. **Clone the repository:**
   ```bash
   git clone https://github.com/Wisc-HCI/AQuA.git
   cd AQuA
   ```

2. **Frontend Setup:**
   - Navigate to the React frontend directory and install dependencies:
     ```bash
     cd AQuA/React_ver/react_Frontend
     npm install
     ```

3. **Backend Setup:**
   - Navigate to the Flask backend directory and set up the environment:
     ```bash
     cd AQuA/React_ver/flask_Backend
     pip install -r requirements.txt
     ```

#### Usage

1. **Start the Backend:**
   - Run the Flask server:
     ```
     python3 app.py
     ```

2. **Start the Frontend:**
   - Run the React development server:
     ```
     npm start
     ```

3. **Access the Application:**
   - Open your browser and navigate to `http://localhost:3000`.

#### FrontEnd Components

#### App.js
   - The main container that integrates video display, prompting, and timeline visualization.
   - Fetches and manages timeline data from the backend.
   - Uses `VideoDisplay` to display video content, `Prompting` for user interaction, and `Scheduler` for timeline visualization.

### Expanded Details on the `Prompting.js` and `VideoDisplay.js` Components

---
#### Prompting.js Component

The `Prompting.js` component serves as the interactive chat interface where users can communicate with the backend's Large Language Model (LLM) API. It is a crucial part of the VLM project, enabling dynamic and conversational interactions between the user and the system.

**Component Breakdown:**

1. **State Management:**
   - `messages`: Holds an array of objects representing the conversation history. Each message object contains the `text` of the message and the `sender` (either 'bot', 'person', or 'llm').
   - `question`: Stores the current user input from the text box.
   - `suggestions`: Contains an array of follow-up questions generated by the LLM, offering users potential next steps in the conversation.

2. **Effects:**
   - **Initialize Conversation (`useEffect`)**: On component mount, an initial message ("How can I help you?") is set from the bot, welcoming the user.
   - **Auto-Scroll (`useEffect`)**: Whenever a new message is added to the `messages` state, the chat box automatically scrolls to the bottom, ensuring the latest message is always visible.

3. **Event Handlers:**
   - `handleQuestionChange`: Updates the `question` state as the user types their input.
   - `handleAskQuestion`: 
     - Validates the user input, ensuring it's not empty.
     - Adds the user's question to the `messages` state.
     - Sends the input to the backend API (`/chat`) via an asynchronous POST request using Axios.
     - Handles the response by adding the LLM's answer to the `messages` state and populating `suggestions` with up to four follow-up questions.
     - Handles errors by displaying an error message in the chat.
   - `handleKeyPress`: Enables submitting the question by pressing the Enter key, providing a smoother user experience.
   - `handleSuggestionClick`: Autofills the suggestion clicked by the user into the input box, making it easier for them to continue the conversation without retyping.

4. **Rendering:**
   - **Chat Box (`chat-box`)**: Displays the conversation history. Each message is styled according to its sender, making it visually clear who said what.
   - **Input Box (`input-box`)**: Contains the input field and a submit button. Users type their questions here, and the button or Enter key triggers the question submission.
   - **Suggestions (`suggestions-container`)**: Displays clickable suggestion bubbles if any follow-up questions are available. Clicking on a suggestion autofills it into the input box.

**Technical Considerations:**
- **Error Handling:** Ensures that the application remains robust by catching and displaying errors that occur during the API request.
- **User Experience:** The auto-scroll and suggestion features enhance usability, ensuring that the interface is responsive and intuitive.

---

#### VideoDisplay.js Component

The `VideoDisplay.js` component is responsible for displaying video and audio content fetched from the backend. It provides a user interface to trigger the analysis script and to view the results of the analysis, such as the most recent video and audio files processed by the backend.

**Component Breakdown:**

1. **Props:**
   - `setAvScript`, `setTimeline`, `setObjects`: These props are placeholders for future extensions where additional data such as scripts, timelines, and objects might be managed or displayed. Currently, these are not used within the component.

2. **State Management:**
   - `videoUrl`: Stores the URL of the video fetched from the backend, allowing it to be played back in the UI.
   - `audioUrl`: Stores the URL of the audio fetched from the backend, allowing it to be played back in the UI.

3. **Functions:**
   - **`runScript`**:
     - Sends a POST request to the backend endpoint `/run-script` to execute a script that processes video and audio files.
     - Upon successful script execution, it triggers the fetching of the most recent video and audio files.
     - Handles any errors during the script execution and logs them.
   
   - **`fetchMostRecentVideo`**:
     - Sends a GET request to `/video/recent` to fetch the most recent video file.
     - Converts the response (which is in blob format) into an object URL that can be used in the `src` attribute of a video element.
     - Updates the `videoUrl` state with the fetched video URL.
     - Includes error handling to manage issues such as network errors or invalid responses.

   - **`fetchMostRecentAudio`**:
     - Sends a GET request to `/audio/recent` to fetch the most recent audio file.
     - Converts the response blob into an object URL suitable for the `src` attribute of an audio element.
     - Updates the `audioUrl` state with the fetched audio URL.
     - Includes error handling similar to the `fetchMostRecentVideo` function.

4. **Rendering:**
   - **Header (`video-header`)**: Displays the title "Video Display," providing context for the user.
   - **Button**: A button labeled "Upload and Analyze" triggers the `runScript` function when clicked. This button initiates the process of running the analysis script and updating the UI with the latest video and audio.
   - **Video Element**: If a `videoUrl` is present, the component renders a video player that allows users to watch the analyzed video.
   - **Audio Element**: Similarly, if an `audioUrl` is present, an audio player is rendered, allowing users to listen to the associated audio.

**Technical Considerations:**
- **Cross-Origin Resource Sharing (CORS):** The requests made by this component handle CORS, ensuring that resources are shared securely across different origins.
- **Error Handling:** The component includes robust error handling for network requests, ensuring that any issues are logged and do not disrupt the user experience.
- **User Experience:** The component is designed to be straightforward and user-friendly, allowing users to initiate an analysis and view the results with minimal effort.

---

These expanded details provide a comprehensive understanding of how the `Prompting.js` and `VideoDisplay.js` components function, their structure, and how they interact with the backend API. This level of detail is essential for maintaining and extending these components in the future.

#### Backend API

The VLM project's backend is built using Flask and provides several key endpoints to handle video, audio, JSON data, and interactions with a Large Language Model (LLM). Below is a detailed description of each endpoint, including their purpose, expected inputs, and outputs.

**1. `/upload` [POST]**

- **Purpose:**  
  Handles the upload of video and audio files and stores them in the database.

- **Request:**
  - **Method:** POST
  - **Content-Type:** multipart/form-data
  - **Body:** 
    - `video`: Video file (binary)
    - `audio`: Audio file (binary)
  
- **Response:**
  - **Success:** 
    ```json
    {
      "message": "Video and audio uploaded successfully"
    }
    ```
  - **Failure:**
    ```json
    {
      "error": "Failed to upload video and audio",
      "message": "<error details>"
    }
    ```

- **Error Handling:**  
  If an error occurs during the upload process (e.g., file reading issues, database errors), a 500 status code is returned with an error message.

---

**2. `/video/recent` [GET]**

- **Purpose:**  
  Retrieves and sends the most recently uploaded video file.

- **Request:**
  - **Method:** GET

- **Response:**
  - **Success:** 
    - Sends the most recent video file as an attachment.
  - **Failure:**
    ```json
    {
      "error": "Failed to retrieve the most recent video and audio",
      "message": "<error details>"
    }
    ```

- **Error Handling:**  
  If no video records are found or if an error occurs during retrieval, a 404 or 500 status code is returned with an error message.

---

**3. `/audio/recent` [GET]**

- **Purpose:**  
  Retrieves and sends the most recently uploaded audio file.

- **Request:**
  - **Method:** GET

- **Response:**
  - **Success:** 
    - Sends the most recent audio file as an attachment.
  - **Failure:**
    ```json
    {
      "error": "Failed to retrieve the most recent audio",
      "message": "<error details>"
    }
    ```

- **Error Handling:**  
  Similar to `/video/recent`, errors during the retrieval process are handled with appropriate status codes and error messages.

---

**4. `/upload-json` [PUT]**

- **Purpose:**  
  Uploads and associates JSON data with the most recently uploaded video.

- **Request:**
  - **Method:** PUT
  - **Content-Type:** application/json
  - **Body:** JSON object containing the data to be associated with the video.

- **Response:**
  - **Success:** 
    ```json
    {
      "message": "JSON data updated successfully"
    }
    ```
  - **Failure:**
    ```json
    {
      "error": "Failed to update JSON data",
      "message": "<error details>"
    }
    ```

- **Error Handling:**  
  Errors such as missing JSON data or no recent video found are handled with 400 or 404 status codes, respectively. Other issues during the process will return a 500 status code with an error message.

---

**5. `/retrieve-json` [GET]**

- **Purpose:**  
  Retrieves the JSON data associated with the most recently uploaded video.

- **Request:**
  - **Method:** GET

- **Response:**
  - **Success:** 
    - Returns the JSON data associated with the most recent video.
  - **Failure:**
    ```json
    {
      "error": "Failed to retrieve JSON data",
      "message": "<error details>"
    }
    ```

- **Error Handling:**  
  If no JSON data is found or an error occurs during retrieval, a 404 or 500 status code is returned with an appropriate error message.

---

**6. `/run-script` [POST]**

- **Purpose:**  
  Executes an external Python script located on the server. This script is responsible for processing the video and audio files.

- **Request:**
  - **Method:** POST

- **Response:**
  - **Success:** Returns `"True"` if the script executes successfully.
  - **Failure:** Returns `"False"` if an error occurs during script execution.

- **Error Handling:**  
  Errors during script execution are caught and the response `"False"` is returned, indicating failure.

---

**7. `/chat` [POST]**

- **Purpose:**  
  Interacts with an external Large Language Model (LLM) API to generate a response and dynamic follow-up questions based on user input.

- **Request:**
  - **Method:** POST
  - **Content-Type:** application/json
  - **Body:** JSON object with a key `prompt` containing the user's question.
    ```json
    {
      "prompt": "Your question here"
    }
    ```

- **Response:**
  - **Success:** 
    ```json
    {
      "answer": "LLM's answer to the prompt",
      "suggestions": ["Follow-up question 1", "Follow-up question 2", ...]
    }
    ```
  - **Failure:** 
    ```json
    {
      "error": "<error details>"
    }
    ```

- **Error Handling:**  
  Errors in communicating with the LLM API, such as network issues or API errors, are logged, and a 500 status code is returned with an error message.
